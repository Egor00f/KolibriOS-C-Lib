.TH "KolibriLib::childWindow" 3 "KolibriLib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KolibriLib::childWindow \- Дочерние окна  

.SH SYNOPSIS
.br
.PP
.SS "Variables"

.in +1c
.ti -1c
.RI "std::string \fBMessage\fP"
.br
.ti -1c
.RI "std::string \fBTitle\fP"
.br
.ti -1c
.RI "bool \fBUsed\fP = false"
.br
.ti -1c
.RI "<<<<<<< Updated upstream void RenderMessageWindow(void) { std::string _Message=Message;std::string _Title=Title;\fBwindow::Window\fP window(_Title, {256, 128});\fBUI::Size\fP WindowSize=window\&.GetSize();\fBUI::text::TextLabel\fP message({(int) window\&.GetMargin(), WindowSize\&.y/2 }, {WindowSize\&.x, WindowSize\&.y/2}, _Message);message\&.SetScale(true);window\&.CreateText(message);while(true) { \fBOS::Event\fP event=window\&.Handler();if(event=OS::Events::Exit) { window\&.~Window();return;} } }=======void RenderMessageWindow(void *);> > > > > > Stashed changes<<<<<<< Updated upstream void MessageBox(std::string _Message, std::string _Title) { while(true) { if(!Used) { Used=true;Message=_Message;Title=_Title;Used=true;\fBThread::CreateThread\fP((void(*)) RenderMessageWindow, 4096);Used=false;return;} else { \fBWait\fP(1);} } }=======void MessageBox(const std::string &_Message, const std::string &_Title);> > > > > > Stashed changes voi \fBErrorWindow\fP )(const std::string &ErrorMessage)"
.br
.RI "Создать окно с сообщением "
.in -1c
.SH "Detailed Description"
.PP 
Дочерние окна 
.SH "Variable Documentation"
.PP 
.SS "void KolibriLib::childWindow::ErrorWindow (const std::string & ErrorMessage)\fR [inline]\fP"

.PP
Создать окно с сообщением 
.PP
\fBParameters\fP
.RS 4
\fIMessage\fP сообщение 
.br
\fITitle\fP Заголовок
.RE
.PP
окошко с ошибкой 
.PP
\fBParameters\fP
.RS 4
\fIErrorMessage\fP сообщение об ощибке 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for KolibriLib from the source code\&.
